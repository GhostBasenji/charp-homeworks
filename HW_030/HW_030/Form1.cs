// Программа для чтения/записи бинарных файлов с использованием потока данных
namespace HW_030
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            textBox1.Clear(); textBox2.Clear(); textBox3.Clear();
        }

        private void button1_Click(object sender, EventArgs e)
        {
            // Чтение бинарного файла
            if (System.IO.File.Exists(@"D:\student.usp") == false) return;
            var Reader = new System.IO.BinaryReader(
                System.IO.File.OpenRead(@"D:\sudetnt.usp"));
            try
            {
                var Nomer_pp = Reader.ReadInt32();
                var FIO = Reader.ReadString();
                var Sredball = Reader.ReadSingle();
                textBox1.Text = Convert.ToString(Nomer_pp);
                textBox2.Text = Convert.ToString(FIO);
                textBox3.Text = Convert.ToString(Sredball);
            }
            finally { Reader.Close(); }
        }

        private void button2_Click(object sender, EventArgs e)
        {
            // Запись бинарного файла
            var Writer = new System.IO.BinaryWriter(
                System.IO.File.Open(@"D:\student.usp",
                System.IO.FileMode.Create));
            try
            {
                var Nomer_pp = Convert.ToInt32(textBox1.Text);
                var FIO = Convert.ToString(textBox2.Text);
                // Разрешаем как запятую, так и точку:
                textBox3.Text = textBox3.Text.Replace(".", ",");
                var Sredball = Convert.ToSingle(textBox3.Text);
            Writer.Write(Nomer_pp);
            Writer.Write(FIO);
            Writer.Write(Sredball);
            }
            finally { Writer.Close(); }
        }
    }
}

// Запись файла на диск происходит при обработке события button2.Click, т. е. щелчка мышью на кнопке Сохранить.
// С этой целью создаем поток байтов Writer для открытия файла student.usp.
// Если такого файла не существует, то он создается (Create), а если файл уже есть, то он перезаписывается.
// Как видно из текста программы, для ее упрощения мы не использовали элемент управления OpenFileDialog открытия файла в диалоге. 
// Далее преобразуем записанное в текстовых полях в более естественные типы данных.
// Номер по порядку Nomer_pp — это тип целых чисел, преобразование в целый тип может быть реализовано операцией Convert.ToInt32 (можно использовать другие функции
// преобразования), для переменной Sredball (средний балл) больше всего подходит тип с плавающей точкой Single, при этом преобразование осуществляется операцией
// Convert.ToSingle. Преобразование для строковой переменной ФИО является необязательным и приведено для симметрии записей. Операторы Writer.Write записывают эти
// данные в файл. После блока finally происходит обязательное закрытие (Close) файла.

// Чтение файла выполняется при обработке события "щелчок мышью на кнопке "Читать"". Как уже упоминалось, для максимального упрощения в данной программе не
// предусмотрено открытие файла через стандартное диалоговое окно, поэтому в начале процедуры выясняем, существует ли такой файл. Если файла D:\student.usp нет, то
// программируем выход (return) из обработчика данного события. Заметьте, чтобы программисту было максимально легко отслеживать ветви оператора if, мы написали:
// "Если файла нет, то return". При этом длинная ветвь логики "если файл есть" не включена непосредственно в оператор if. Поэтому такой фрагмент программного кода
// читается программистом легко — это типичный пример хорошо написанного программного кода.
// Далее создается поток байтов Reader из файла student.usp, открытого для чтения. Чтение из потока в каждую переменную реализовано с помощью функции ReadInt32 —
// читать из потока Reader в переменную целого типа, аналогично функциям ReadString и ReadSingle. Затем осуществлено конвертирование этих переменных в строковый тип 
// Convert.ToString. Как видно из программы, можно было изначально все текстовые поля записывать в файл без конвертирования, но при дальнейшем развитии этой программы 
// значения полей все равно пришлось бы преобразовывать в соответствующий тип. После блока finally происходит закрытие (Close) файла. Блок finally выполнится всегда,
// даже если перед ним была команда return. 

// Дальнейшее развитие этой программы может быть осуществлено путем добавления в файл сведений о других студентах.
// В таком случае при чтении файла количество студентов будет неизвестно.
// Тогда следует обработать ситуацию достижения конца файла: 
// catch (EndOfStreamException e) 
// а затем закрыть файл. 